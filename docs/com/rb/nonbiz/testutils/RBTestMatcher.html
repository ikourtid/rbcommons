<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Tue Apr 09 21:31:06 EDT 2024 -->
<title>RBTestMatcher</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2024-04-09">
<meta name="description" content="declaration: package: com.rb.nonbiz.testutils, class: RBTestMatcher">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":10,"i1":6,"i2":6,"i3":6,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.rb.nonbiz.testutils</a></div>
<h1 title="Class RBTestMatcher" class="title">Class RBTestMatcher&lt;T&gt;</h1>
</div>
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">com.rb.nonbiz.testutils.RBTestMatcher&lt;T&gt;</div>
</div>
<section class="description">
<hr>
<pre>public abstract class <span class="type-name-label">RBTestMatcher&lt;T&gt;</span>
extends java.lang.Object</pre>
<div class="block">Unit tests for a data class Settings (example) should extend <code>RBTestMatcher&lt;Settings&gt;</code>.

 This is a convenience to force you to do a subset of the necessary testing
 when a data class has a matcher created for it.
 By 'subset' we mean that this infrastructure can't force you to test your static constructors
 under various inputs to see if they fail. It's mostly to test the matcher, plus to verify
 that instantiation of some simple objects won't throw an exception.

 So: you usually need to add more tests to a data class unit test class!

 RBTestMatcher creates an inherited unit test that will compare a trivial object
 (e.g. an empty one - usually there is such a thing with collections etc),
 against a nontrivial object, and another object that matches that nontrivial object.
 All checks will happen in matcherMetaTest, so you don't have to remember yourself to do them in your own test class.

 There should be a public matcher with the following signature and name. The contents of the method
 should try to match all fields in the object that we care about matching.
 Static methods can't be part of an interface definition, so it's not possible to force you to create them
 (i.e. to have the code not compile otherwise). But here is a rough outline, using the examples below:

 <pre> <code>
 public static TypeSafeMatcher&lt;Settings&gt; settingsMatcher(Settings expected) {
   return makeMatcher(expected,
     match(v -&gt; v.getIntSetting(),     f -&gt; typeSafeEqualTo(f)),
     match(v -&gt; v.getDoubleSetting1(), f -&gt; doubleAlmostEqualsMatcher(f, 1e-8)),
     match(v -&gt; v.getDoubleSetting2(), f -&gt; doubleAlmostEqualsMatcher(f, 1e-8)));
 }</code> </pre>

 This says '2 objects of type Settings are considered equal (for testing purposes)
 if their intSetting field is exactly the same, and their doubleSetting1 and 2 (respectively) fields
 are 'almost the same'.

 Note that there exist some handy shortcuts in special cases where we check for equality and for
 'numbers almost equal'. Here is an equivalent version of the matcher above, but shorter:

 <pre> <code>
 public static TypeSafeMatcher&lt;Settings&gt; settingsMatcher(Settings expected) {
   return makeMatcher(expected,
     matchUsingEquals(v -&gt; v.getIntSetting()),
     matchUsingAlmostEquals(v -&gt; v.getDoubleSetting1(), 1e-8),
     matchUsingAlmostEquals(v -&gt; v.getDoubleSetting2(), 1e-8));
 }</code> </pre>

 Sometimes you will see an older style of this static matcher, which looks like this:

 <pre> <code>
 public static TypeSafeMatcher&lt;Settings&gt; settingsMatcher(Settings expected) {
   return makeMatcher(expected, actual -&gt;
     expected.getIntSetting().equals(actual.getIntSetting()))
     &amp;&amp; doubleAlmostEqualsMatcher(expected.getDoubleSetting1(), 1e-8).matches(actual.getDoubleSetting1())
     &amp;&amp; doubleAlmostEqualsMatcher(expected.getDoubleSetting2(), 1e-8).matches(actual.getDoubleSetting2()));
 }</code> </pre>

 This is a bit more error-prone, because the left and right side needs to be repeated, and it's easy to mess up.
 However, there is a subset of cases where you need to use that.
 When? Well, you'll notice because the code won't compile.

 Note that we (intentionally) rarely want to match on HumanReadableLabel. This is the one exception.
 The whole point of the label is that its values are only for reading, and should never affect logic.</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Constructors</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Constructor</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E()">RBTestMatcher</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="table-tab" onclick="show(4);">Abstract Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code><a href="RBTestMatcher.html" title="type parameter in RBTestMatcher">T</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#makeDummyObject()">makeDummyObject</a></span>()</code></th>
<td class="col-last">
<div class="block">We often need to create *some* valid object of a class, but its value doesn't matter in the logic.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>abstract <a href="RBTestMatcher.html" title="type parameter in RBTestMatcher">T</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#makeMatchingNontrivialObject()">makeMatchingNontrivialObject</a></span>()</code></th>
<td class="col-last">
<div class="block">Like makeNontrivialObject, except that this should generate an object which is slightly different,
 but which we want to match the output of makeNontrivialObject - i.e.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>abstract <a href="RBTestMatcher.html" title="type parameter in RBTestMatcher">T</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#makeNontrivialObject()">makeNontrivialObject</a></span>()</code></th>
<td class="col-last">
<div class="block">Create a 'general' object, i.e.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>abstract <a href="RBTestMatcher.html" title="type parameter in RBTestMatcher">T</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#makeTrivialObject()">makeTrivialObject</a></span>()</code></th>
<td class="col-last">
<div class="block">Create the simplest test object you can think of.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#matcherMetaTest()">matcherMetaTest</a></span>()</code></th>
<td class="col-last">
<div class="block">This is unusual with unit tests, but this test gets inherited and executes whenever each
 parent class's tests execute.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testGetHumanReadableLabelOnAll3Objects_ifHasHumanReadableLabel()">testGetHumanReadableLabelOnAll3Objects_ifHasHumanReadableLabel</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testToMultilineStringOnAll3Objects_ifPrintsMultilineString()">testToMultilineStringOnAll3Objects_ifPrintsMultilineString</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testToStringOnAll3Objects()">testToStringOnAll3Objects</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testToStringOnAll3Objects_ifPrintsInstruments()">testToStringOnAll3Objects_ifPrintsInstruments</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>protected abstract boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#willMatch(T,T)">willMatch</a></span>&#8203;(<a href="RBTestMatcher.html" title="type parameter in RBTestMatcher">T</a>&nbsp;expected,
<a href="RBTestMatcher.html" title="type parameter in RBTestMatcher">T</a>&nbsp;actual)</code></th>
<td class="col-last">
<div class="block">Since you should always have a static matcher (in the example above, settingsMatcher),
 this should just call the static matcher, and do nothing else.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>RBTestMatcher</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">RBTestMatcher</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="makeTrivialObject()">
<h3>makeTrivialObject</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="RBTestMatcher.html" title="type parameter in RBTestMatcher">T</a></span>&nbsp;<span class="member-name">makeTrivialObject</span>()</div>
<div class="block">Create the simplest test object you can think of. Examples:
 * if you are testing a map, this should return an empty map.
 * if you are testing a data class that stores an int and 2 doubles,
   this should return something like (0, 0.0, 0.0) if that is a valid value. Code example:

 <pre>
 <code>@Override</code>
 <code>public Settings makeTrivialObject() {
   return settings(0, 0.0, 0.0);
 }</code> </pre></div>
</section>
</li>
<li>
<section class="detail" id="makeNontrivialObject()">
<h3>makeNontrivialObject</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="RBTestMatcher.html" title="type parameter in RBTestMatcher">T</a></span>&nbsp;<span class="member-name">makeNontrivialObject</span>()</div>
<div class="block">Create a 'general' object, i.e. not a trivially simple one.
 * if you are testing a map, this should return a map of &gt; 1 item.
 * if you are testing a data class that stores an int and 2 doubles,
 this should return something like (100, -1.1, 2.2) if it is a valid value. Code example:

 <pre>
 <code>@Override</code>
 <code>public Settings makeTrivialObject() {
   return settings(100, -1.1, 2.2);
 }</code> </pre></div>
</section>
</li>
<li>
<section class="detail" id="makeDummyObject()">
<h3>makeDummyObject</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="RBTestMatcher.html" title="type parameter in RBTestMatcher">T</a></span>&nbsp;<span class="member-name">makeDummyObject</span>()</div>
<div class="block">We often need to create *some* valid object of a class, but its value doesn't matter in the logic.
 Use this when you want to have explicit semantics about needing a dummy value.
 This is somewhat less of an issue if you create a local variable, where you can add 'dummy' in its name,
 but it's useful when you're using such a dummy object in-line, which means you'd otherwise have to have a comment.</div>
</section>
</li>
<li>
<section class="detail" id="makeMatchingNontrivialObject()">
<h3>makeMatchingNontrivialObject</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="RBTestMatcher.html" title="type parameter in RBTestMatcher">T</a></span>&nbsp;<span class="member-name">makeMatchingNontrivialObject</span>()</div>
<div class="block">Like makeNontrivialObject, except that this should generate an object which is slightly different,
 but which we want to match the output of makeNontrivialObject - i.e. 'not too different'.
 As per the examples above:

 <pre>
 <code>@Override</code>
 <code>public Settings makeTrivialObject() {
   double e = 1e-9; // epsilon
   return settings(100, -1.1 + e, 2.2 + e);
 }</code>
 </pre>

 In the case above, if we hardcode the static matcher to consider double values within 1e-8 as matching
 (even when slightly unequal), then perturbing the double values of the original object by 1e-9 &lt; 1e-8
 should result in matching objects.

 In some cases, there may not be a meaningful value for this other than makeNontrivialObject.
 E.g. if settings only took ints, there would not be some well-defined notion
 of 'different, but not too different'. Same goes for e.g. a string.</div>
</section>
</li>
<li>
<section class="detail" id="willMatch(T,T)">
<h3 id="willMatch(java.lang.Object,java.lang.Object)">willMatch</h3>
<div class="member-signature"><span class="modifiers">protected abstract</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">willMatch</span>&#8203;(<span class="parameters"><a href="RBTestMatcher.html" title="type parameter in RBTestMatcher">T</a>&nbsp;expected,
<a href="RBTestMatcher.html" title="type parameter in RBTestMatcher">T</a>&nbsp;actual)</span></div>
<div class="block">Since you should always have a static matcher (in the example above, settingsMatcher),
 this should just call the static matcher, and do nothing else. Example:

 <pre>
 <code>@Override</code>
 <code>protected boolean willMatch(Settings expected, Settings actual) {
   return settingsMatcher(expected).matches(actual);
 }</code>
 </pre></div>
</section>
</li>
<li>
<section class="detail" id="matcherMetaTest()">
<h3>matcherMetaTest</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">matcherMetaTest</span>()</div>
<div class="block">This is unusual with unit tests, but this test gets inherited and executes whenever each
 parent class's tests execute.

 The idea is that the 2 'nontrivial' objects must match with each other, but not with the trivial one.
 Also, every object must match itself.

 This set of test cases isn't exhaustive, but it's pretty good.</div>
</section>
</li>
<li>
<section class="detail" id="testToStringOnAll3Objects()">
<h3>testToStringOnAll3Objects</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testToStringOnAll3Objects</span>()</div>
</section>
</li>
<li>
<section class="detail" id="testToStringOnAll3Objects_ifPrintsInstruments()">
<h3>testToStringOnAll3Objects_ifPrintsInstruments</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testToStringOnAll3Objects_ifPrintsInstruments</span>()</div>
</section>
</li>
<li>
<section class="detail" id="testGetHumanReadableLabelOnAll3Objects_ifHasHumanReadableLabel()">
<h3>testGetHumanReadableLabelOnAll3Objects_ifHasHumanReadableLabel</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testGetHumanReadableLabelOnAll3Objects_ifHasHumanReadableLabel</span>()</div>
</section>
</li>
<li>
<section class="detail" id="testToMultilineStringOnAll3Objects_ifPrintsMultilineString()">
<h3>testToMultilineStringOnAll3Objects_ifPrintsMultilineString</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testToMultilineStringOnAll3Objects_ifPrintsMultilineString</span>()</div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>
