syntax = "proto3";

option java_package = "com.rb.nonbiz.math.eigen";

// To save you the effort on how to protobuf-compile this:
// cd ~/ssd/rb;
// protoc --java_out=./src/main/java ./src/main/java/com/rb/nonbiz/math/eigen/EigenProto.proto
// protoc --python_out=. ./src/main/java/com/rb/nonbiz/math/eigen/EigenProto.proto
//
// (note that the python command does not look symmetric, but this is the least bad way I could figure out to do this.)
message EigenDecomposition {

    message Eigenpair {
        double eigenvalue = 1;
        repeated double eigenvector_elements = 2;
    }

    message InstrumentLoadings {
        int64 instrument_id = 1;
        repeated double eigenvector_loadings = 2; // in decreasing order of eigenvalue
    }

    message QualityOfReturnsMsg {
        int64 instrument_id = 1;

        // # of returns where both the 'before' and the 'after' prices were available - i.e. the 'happy path'
        int32 num_actual = 2;

        // e.g. due to market halts
        int32 num_gap_filled = 3;

        // This includes any history gap fills we may do for the first day of PRICES, since the first day of
        // RETURNS is the next day (since we need a previous price).
        int32 num_back_filled = 4;
    }

    message StatsMsg {
        int64 instrument_id = 1;

        double annualized_standard_deviation = 2;
    }

    string human_description = 1;

    // Between 0 and 1; we typically try to get enough eigenvectors with eigenvalues
    // such that the explanatory power of the eigenvectors we keep is at most 80% of total.
    // We can always decide to only care about using the biggest factors that only get us to e.g. 70%.
    // Note that this is the MINIMUM; if e.g. it's 80%, and the least important eigenvector takes us from
    // 79% explanatory power to 82% explanatory power, then this will still be 80%.
    double eigenvector_coverage_fraction = 2;

    // this applies to all eigenvectors, not just the ones that are included in this file after skipping
    // the least important ones. It is useful for cases where e.g. we store eigenvectors for up to 80%
    // explanatory power, but decide to use up to 70% for a backtest. We can always choose less.
    double sum_of_all_eigenvalues_including_skipped = 3;

    repeated QualityOfReturnsMsg all_quality_of_returns = 4;

    repeated Eigenpair retained_eigenpairs_descending = 5;

    repeated InstrumentLoadings instrument_factor_loadings = 6;

    repeated StatsMsg stats = 7;

}