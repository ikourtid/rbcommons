package com.rb.nonbiz.collections;

import com.rb.nonbiz.text.Strings;

import java.util.Collection;
import java.util.Comparator;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Supplier;

import static com.rb.nonbiz.collections.RBMapSimpleConstructors.emptyRBMap;
import static com.rb.nonbiz.collections.RBSet.newRBSet;

/**
 * Like an {@link RBMap}, except that this also stores a value that's supposed to mean 'regardless of key'.
 * For example, this is useful if you want to store trading notional by side (buy/sell), but also the total
 * (i.e. regardless of category).
 *
 * <p> The valueRegardlessOfCategory does not have to use additive semantics, like it would with buy / sell notional.
 * For example, we could be storing orders by order reason (TLH, rebalance, etc.) We may decide to double-count some. </p>
 *
 * <p> This is very similar to {@link RBMapWithDefault}, but the semantics are different. The single value here has
 * semantics of 'applies to the total', not 'if you don't find it in the map, use this'. </p>
 */
public class RBCategoryMap<K, V> {

  private final V valueRegardlessOfCategory;
  private final RBMap<K, V> rawMap;

  private RBCategoryMap(V valueRegardlessOfCategory, RBMap<K, V> rawMap) {
    this.valueRegardlessOfCategory = valueRegardlessOfCategory;
    this.rawMap = rawMap;
  }

  public static <K, V> RBCategoryMap<K, V> rbCategoryMap(V valueRegardlessOfCategory, RBMap<K, V> rawMap) {
    return new RBCategoryMap<>(valueRegardlessOfCategory, rawMap);
  }

  public static <K, V> RBCategoryMap<K, V> emptyRBCategoryMap(V valueRegardlessOfCategory) {
    return new RBCategoryMap<>(valueRegardlessOfCategory, emptyRBMap());
  }

  /**
   * Creates an RBCategoryMap with the supplied value under the specified keys,
   * as well as the 'regardless of category' key.
   *
   * Typically, the default value supplier will return a new object (pointer-wise) for each key,
   * but it will be the same in terms of contents, if the supplier is stateless, which it should be.
   */
  public static <K, V> RBCategoryMap<K, V> rbCategoryMap(
      Collection<K> keys, Supplier<V> defaultValueSupplier) {
    return rbCategoryMap(
        keys,
        defaultValueSupplier.get(),
        key -> defaultValueSupplier.get());
  }

  /**
   * Creates an RBCategoryMap with the supplied value under the 'regardless of category' key,
   * and with values for the other keys generated by a function.
   */
  public static <K, V> RBCategoryMap<K, V> rbCategoryMap(
      Collection<K> keys, V valueRegardlessOfCategory, Function<K, V> keyToValue) {
    return new RBCategoryMap<K, V>(
        valueRegardlessOfCategory,
        newRBSet(keys).toRBMap(keyToValue));
  }

  public V getValueRegardlessOfCategory() {
    return valueRegardlessOfCategory;
  }

  public RBMap<K, V> getRawMap() {
    return rawMap;
  }

  public Optional<V> getOptional(K key) {
    return rawMap.getOptional(key);
  }

  public V getOrThrow(K key) {
    return rawMap.getOrThrow(key);
  }

  @Override
  public String toString() {
    return Strings.format("[RBCM all= %s %s RBCM]",
        valueRegardlessOfCategory, rawMap);
  }

  // K does not implement comparable; that would be too restrictive.
  // However, in those cases where you want this to print the raw map in a fixed order, it's better to use this.
  public String toString(Comparator<K> keyComparator) {
    return Strings.format("[RBCM all= %s %s RBCM]",
        valueRegardlessOfCategory, Strings.formatMapInKeyOrder(rawMap, keyComparator, " "));
  }

}
